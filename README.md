# 学习 23 种设计模式 JavaScript version

## Motivation

何为设计模式？

> 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案, 设计模式的主题总是把不变的事物和变化的事物分离开来.

为什么要学设计模式呢?

为了能写出可维护, 高质量的代码？准备读 react 源码了, 各种观察者模式, 代理模式看不懂？

大抵如此吧, 也许短时间看不出什么效果, 但内心深处一直觉得学习它有深远的意义.

或许时间会给予答案.

最后以鲁迅先生的原话做结, 共勉之.

> (1) 没学设计模式前一点也不懂, 根本想不到设计模式, 设计的代码很糟糕.
>
> (2) 学了几个设计模式后, 很开心, 于是到处想着要用自己学过的模式, 于是时常造成误用模式而不知.
>
> (3) 学完全部模式时, 感觉诸多的设计模式极为相似, 无法分清设计模式之间的差异, 有困惑, 但深知误用之害, 应用之时有所犹豫.
>
> (4) 灵活应用模式, 甚至不应用具体的某种模式也能设计出优秀的代码, 以达到无剑胜有剑的境界.

## Principle

- 开闭原则

- 里氏替换原则

- 依赖倒置原则

- 单一职责原则

- 最少知道原则

- 接口分离原则

## Menu

- 创建型

  - [单例模式](./docs/Singleton.md): 确保一个类仅有一个实例, 并提供一个访问它的全局访问点.

  - [原型模式](./docs/Prototype.md): 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象.

  - 生成器模式

  - 工厂模式

- 结构型

  - 装饰器模式

  - 外观模式

  - [代理模式](./docs/Proxy.md): 代理模式是为一个对象提供一个代用品或占位符, 以便控制对它的访问.

  - [享元模式](./docs/Flyweight.ts): 享元模式的核心是运用共享技术来有效支持大量细粒度的对象.

  - 桥接模式

  - 适配器模式

- 行为型

  - [策略模式](./docs/Strategy.md): 定义一系列算法, 把它们一个个封装起来, 并且使它们可以互相替换.

  - 职责链模式

  - 解释器模式

  - [迭代器模式](./dos/Iterator.md): 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示.

  - [命令模式](./docs/Command.md): 将一个请求封装为一个对象, 从而使我们可用不同的请求对客户进行参数化; 对请求排队或者记录请求日志, 以及支持可撤销的操作.

  - [发布-订阅模式(观察者模式)](./docs/Observable.md): 观察者模式定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都将得到通知.

  - [组合模式](./docs/Composite.md): 组合模式将对象组合成树形结构, 以表示"部分 - 整体"的层次结构.

  - [模版方法模式](./docs/TemplateMethod.md): 模版方法模式基于继承, 需要提供一个抽象类, 然后让子类继承.

  - 中介者模式

  - 备忘录模式

  - 状态模式

## License

Design Patterns is [MIT licensed](https://opensource.org/licenses/MIT).
